# PgVibe Development Philosophy & Guidelines

## Core Philosophy: Declarative Schema Management

PgVibe is a **declarative** PostgreSQL schema management tool. This means:

### ✅ What We Support (Declarative)

Users define the **desired end state** of their database schema:

```sql
-- GOOD: Declarative - defines what the schema should look like
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  title VARCHAR(255) NOT NULL,
  CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### ❌ What We DON'T Support (Imperative)

We do NOT support imperative statements that describe how to change the schema:

```sql
-- BAD: Imperative - describes steps to change schema
ALTER TABLE users ADD COLUMN email VARCHAR(255);
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
ALTER TABLE posts ADD CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id);
DROP TABLE old_table;
```

## Why This Matters

1. **Simplicity**: Users only need to think about their desired schema, not migration steps
2. **Idempotency**: Running the same schema file multiple times produces the same result
3. **Version Control**: Schema files represent complete states, making diffs meaningful
4. **Reliability**: PgVibe figures out the optimal migration path automatically

## Handling Complex Scenarios

### Circular Foreign Keys

For circular dependencies, use inline constraint syntax:

```sql
-- Tables can reference each other using inline constraints
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  manager_id INTEGER REFERENCES employees(id),  -- Self-reference
  department_id INTEGER,
  CONSTRAINT fk_department FOREIGN KEY (department_id) REFERENCES departments(id)
);

CREATE TABLE departments (
  id SERIAL PRIMARY KEY,
  head_employee_id INTEGER,
  CONSTRAINT fk_head FOREIGN KEY (head_employee_id) REFERENCES employees(id)
);
```

### Schema Evolution

Users provide complete schema snapshots at different points in time:

```sql
-- schema-v1.sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);

-- schema-v2.sql (complete schema, not just changes)
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(255) NOT NULL  -- New column
);
```

## Parser Implementation Guidelines

### DO:
- Parse `CREATE TABLE` statements with all inline constraints
- Parse `CREATE INDEX` statements
- Support all PostgreSQL constraint types inline (PRIMARY KEY, FOREIGN KEY, CHECK, UNIQUE)
- Parse complete schema definitions

### DON'T:
- Parse `ALTER TABLE` statements
- Parse `DROP` statements (except when generated by the differ)
- Support migration-specific syntax
- Add imperative constructs

### Example Parser Check:

```typescript
// In parser.ts
if (statement.type === "alter_table_stmt") {
  throw new Error(
    "ALTER TABLE statements are not supported. " +
    "Please define your complete desired schema using CREATE TABLE statements."
  );
}
```

## Testing Philosophy

Tests should use declarative schema definitions:

```typescript
// GOOD: Test with complete schema
test("should handle foreign keys", async () => {
  const schema = `
    CREATE TABLE users (
      id SERIAL PRIMARY KEY
    );
    CREATE TABLE posts (
      id SERIAL PRIMARY KEY,
      user_id INTEGER,
      CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id)
    );
  `;
  await schemaService.apply(schema);
});

// BAD: Don't test with ALTER statements
test("should add foreign key", async () => {
  const schema = `
    CREATE TABLE users (id SERIAL PRIMARY KEY);
    CREATE TABLE posts (id SERIAL PRIMARY KEY, user_id INTEGER);
    ALTER TABLE posts ADD CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id);
  `;
  // This should not be supported!
});
```

## User Documentation

Always remind users that PgVibe is declarative:

- "Define what you want, not how to get there"
- "Your schema file should represent the complete desired state"
- "PgVibe figures out the migration steps automatically"

## Migration Generation

The **differ** is responsible for generating any necessary `ALTER`, `DROP`, or other imperative statements. Users never write these directly.

## Summary

PgVibe follows the same philosophy as Terraform, Kubernetes, and other modern infrastructure tools: **declarative configuration**. This makes schemas easier to understand, version control, and maintain.